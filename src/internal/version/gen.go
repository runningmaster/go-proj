// +build ignore

package main

// This program generates version_gen.go. Invoke it as
//	go run gen.go

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

const (
	major      = 0
	minor      = 1
	patch      = 0
	prerelease = "experimental"

	srcFormat = `
		// Generated by go run gen.go
		// Do not edit.
		// This file must be included in .gitignore.

		package version

		const (
			// Major version when you make incompatible API changes.
			Major = %d
			
			// Minor version when you add functionality in a backwards-compatible manner.
			Minor = %d
			
			// Patch version when you make backwards-compatible bug fixes.
			Patch = %d
			
			// PreRelease version may be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version.
			PreRelease = %q
			
			// BuildTime is build metadata and it may be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version.
			BuildTime = %q
			
			// GitCommit is build metadata and it may be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version.
			GitCommit = %q
		)
`
)

func main() {
	flagFile := flag.String("o", "tip.go", "output file name")
	flag.Parse()
	fmt.Printf("go:generate in %s -> %s\n", os.Getenv("GOFILE"), *flagFile)

	buildtime := time.Now().Format("20060102150405")
	gitcommit := "00000000"
	if isGitRepo() {
		//gitCommand := []string{"git", "log", "-n", "1", "--format=format: +%h %cd", "HEAD"}
		gitCommand := []string{"git", "rev-parse", "HEAD"}
		res := make([]byte, len(gitcommit))
		err := execCmd(res, gitCommand...)
		if err != nil {
		}
		gitcommit = string(res)
	}

	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, srcFormat,
		major,
		minor,
		patch,
		prerelease,
		buildtime,
		gitcommit,
	)

	out, err := format.Source(buf.Bytes())
	if err != nil {
		goto Fail
	}

	err = ioutil.WriteFile(*flagFile, out, 0644)
	if err != nil {
		goto Fail
	}

	return // success
Fail:
	panic(fmt.Errorf("can not generate %s: %v", *flagFile, err))
}

// isGitRepo reports whether the working directory is inside a Git repository.
func isGitRepo() bool {
	p := ".git"
	for {
		fi, err := os.Stat(p)
		if os.IsNotExist(err) {
			p = filepath.Join("..", p)
			continue
		}
		if err != nil || !fi.IsDir() {
			return false
		}
		return true
	}
}

// execCmd is simple wrapper for exec.Command
func execCmd(dst []byte, cmd ...string) error {
	b, err := exec.Command(cmd[0], cmd[1:]...).Output()
	if err != nil {
		return err
	}
	copy(dst, b)
	return nil
}
