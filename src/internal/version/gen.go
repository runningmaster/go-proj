// +build ignore

package main

// This program generates version_gen.go. Invoke it as
//	go run gen.go

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

const (
	major      = 0
	minor      = 1
	patch      = 0
	prerelease = "experimental"

	srcFormat = `
		// Generated by go run gen.go
		// Do not edit.
		// This file must be included in .gitignore.

		package version

		const (
			buildtime  = %q
			gitcommit  = %q
		)

		var (
			major      = %d
			minor      = %d
			patch      = %d
			prerelease = %q
		)
`
)

func main() {
	flagFile := *flag.String("o", "tip.go", "output file name")
	flag.Parse()
	fmt.Printf("go:generate in %s -> %s\n", os.Getenv("GOFILE"), flagFile)

	buildtime := time.Now().Format("20060102150405")
	gitcommit := "0000000"
	if isGitRepo() {
		// execCmd("git", "log", "-n", "1", "--format=format: +%h %cd", "HEAD")
		if res, err := execCmd("git", "rev-parse", "--short", "HEAD"); err == nil {
			gitcommit = chomp(string(res))
		}
	}

	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, srcFormat,
		buildtime,
		gitcommit,
		major,
		minor,
		patch,
		prerelease,
	)

	out, err := format.Source(buf.Bytes())
	if err != nil {
		goto fail
	}

	err = ioutil.WriteFile(flagFile, out, 0644)
	if err != nil {
		goto fail
	}

	return // success
fail:
	panic(fmt.Errorf("can not generate %s: %v", flagFile, err))
}

// isGitRepo reports whether the working directory is inside a Git repository.
func isGitRepo() bool {
	p := ".git"
	for {
		fi, err := os.Stat(p)
		if os.IsNotExist(err) {
			p = filepath.Join("..", p)
			continue
		}
		if err != nil || !fi.IsDir() {
			return false
		}
		return true
	}
}

// execCmd is simple wrapper for exec.Command
func execCmd(cmd ...string) ([]byte, error) {
	return exec.Command(cmd[0], cmd[1:]...).Output()
}

// chomp removes trailing spaces.
func chomp(s string) string {
	return strings.TrimRight(s, " \t\r\n")
}
